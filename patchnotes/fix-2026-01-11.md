# Fix 2026-01-11

## Island Isolation & Thread Safety
We discovered a subtle bug in our `ProgramDatabase` that was allowing "Genetic Pollution" between islands. When an island was queried for a program but was temporarily empty, the fallback logic accidentally returned a random program from *any* island in the archive. This broke the rigorous isolation required for island-model evolution.

We fixed this by strictly enforcing island ID checks during sampling. If an island is empty, the system now handles it gracefully or retries properly rather than grabbing a neighbor's genetic material.

```python
# Ensuring what happens on Island 1 stays on Island 1
def sample_from_island(self, island_id):
    # Old: return random.choice(self.archive) -> BUG
    # New: return self.islands[island_id].sample()
```

## Race Conditions
With multiple workers accessing the main database simultaneously, we started seeing occasional "list index out of range" errors. This is a classic race condition where two workers try to read/write to the shared program list at the exact same nanosecond.

We added a `threading.RLock` to the database class. Now, every time a worker wants to sample or update a program, it must acquire a "ticket" (lock), ensuring ensuring the operation completes atomically before the next worker enters.

```python
with self.lock:
    # Critical section: safe to modify lists here
    self.programs.append(new_program)
```
