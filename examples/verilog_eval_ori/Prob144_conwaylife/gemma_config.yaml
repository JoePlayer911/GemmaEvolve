# Configuration for Verilog optimization
max_iterations: 50
checkpoint_interval: 10
log_level: "INFO"
language: "verilog"
file_suffix: ".v"

# LLM configuration
llm:
  models:
    - name: "gemma-local"
      model_path: "/home/jonathan13/GemmaEvolve/gemma-3-12b-it-Q8_0.gguf"
      n_ctx: 8192
      n_gpu_layers: -1
      temperature: 0.7
      top_p: 0.95
      max_tokens: 4096
      
  # Use the same model for evaluation
  evaluator_models:
    - name: "gemma-local" 
      model_path: "/home/jonathan13/GemmaEvolve/gemma-3-12b-it-Q8_0.gguf"
      n_ctx: 8192
      n_gpu_layers: -1
      temperature: 0.7
      top_p: 0.95
      max_tokens: 4096

# Prompt configuration
prompt:
  system_message: |
    You are an expert Hardware Design Engineer. Your task is to implement a Verilog module based on the following description.

    Description:
    The "game" is played on a two-dimensional grid of cells, where each cell
    is either 1 (alive) or 0 (dead). At each time step, each cell changes
    state depending on how many neighbours it has:
    
      (1) 0-1 neighbour: Cell becomes 0.
      (2) 2 neighbours: Cell state does not change.
      (3) 3 neighbours: Cell becomes 1.
      (4) 4+ neighbours: Cell becomes 0.
    
    The game is formulated for an infinite grid. In this circuit, we will use
    a 16x16 grid. To make things more interesting, we will use a 16x16
    toroid, where the sides wrap around to the other side of the grid. For
    example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15),
    (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by
    a length 256 vector, where each row of 16 cells is represented by a
    sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc.
    
      (1) load: Loads data into q at the next clock edge, for loading initial
           state. Active high synchronous.
      (2) q: The 16x16 current state of the game, updated every clock cycle.
    
    The game state should advance by one timestep every clock cycle.

    Interface:
    module TopModule (
      input clk,
      input load,
      input [255:0] data,
      output reg [255:0] q
    );

    Requirements:
    - Implement the module logic using `assign` statements where possible.
    - Follow Verilog-2001 standards.
    - Output ONLY the Verilog module code.
    - Do NOT include the testbench.

  # Reduce context usage
  num_top_programs: 0
  num_diverse_programs: 0
  include_artifacts: false

# Database configuration
database:
  population_size: 10 
  archive_size: 5
  num_islands: 1
  programs_per_island: 10
  elite_selection_ratio: 0.2
  exploitation_ratio: 0.7
  
  # Embedding model (CPU offloaded)
  embedding_model: "embedding_models/Nomic-Embed-Code/nomic-embed-code-q5_k_m.gguf"
  similarity_threshold: 0.95

# Evaluator configuration
evaluator:
  timeout: 30
  parallel_evaluations: 2

# Evolution settings
diff_based_evolution: false 
max_code_length: 5000
