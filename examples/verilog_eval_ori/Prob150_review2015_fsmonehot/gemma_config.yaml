# Configuration for Verilog optimization
max_iterations: 50
checkpoint_interval: 10
log_level: "INFO"
language: "verilog"
file_suffix: ".v"

# LLM configuration
llm:
  models:
    - name: "gemma-local"
      model_path: "/home/jonathan13/GemmaEvolve/gemma-3-12b-it-Q8_0.gguf"
      n_ctx: 8192
      n_gpu_layers: -1
      temperature: 0.7
      top_p: 0.95
      max_tokens: 4096
      
  # Use the same model for evaluation
  evaluator_models:
    - name: "gemma-local" 
      model_path: "/home/jonathan13/GemmaEvolve/gemma-3-12b-it-Q8_0.gguf"
      n_ctx: 8192
      n_gpu_layers: -1
      temperature: 0.7
      top_p: 0.95
      max_tokens: 4096

# Prompt configuration
prompt:
  system_message: |
    You are an expert Hardware Design Engineer. Your task is to implement a Verilog module based on the following description.

    Description:
    Given the following Moore state machine with 3 input (d, done_counting,
    ack) and 3 outputs (shift_ena, counting, done). Unless otherwise stated in
    the diagram below, assume outputs are 0 and inputs are don't cares.
    
    state   (output)      --input--> next state
    -------------------------------------------
      S     ()            --d=0--> S
      S     ()            --d=1--> S1
      S1    ()            --d=0--> S
      S1    ()            --d=1--> S11
      S11   ()            --d=0--> S110
      S11   ()            --d=1--> S11
      S110  ()            --d=0--> S
      S110  ()            --d=1--> B0
      B0    (shift_ena=1) --(always go to next cycle)--> B1
      B1    (shift_ena=1) --(always go to next cycle)--> B2
      B2    (shift_ena=1) --(always go to next cycle)--> B3
      B3    (shift_ena=1) --(always go to next cycle)--> Count
      Count (counting=1)  --done_counting=0--> Count
      Count (counting=1)  --done_counting=1--> Wait
      Wait  (done=1)      --ack=0--> Wait
      Wait  (done=1)      --ack=1--> S
    
    At reset, the state machine starts in state "S". Derive next-state logic
    equations and output logic equations by inspection assuming the following
    one-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait)
    = (10'b0000000001, 10'b0000000010, 10'b0000000100, ... , 10'b1000000000)
    
    Derive state transition and output logic equations by inspection assuming
    a one-hot encoding. Implement only the state transition logic and output
    logic (the combinational logic portion) for this state machine.
    
    Write code that generates the following signals:
    
     - B3_next -- Assert when next-state is B3 state
     - S_next -- Assert when next-state is S state
     - S1_next -- Assert when next-state is S1 state
     - Count_next -- Assert when next-state is Count state
     - Wait_next -- Assert when next-state is Wait state
     - done -- output logic
     - counting -- output logic
     - shift_ena -- output logic

    Interface:
    module TopModule (
      input d,
      input done_counting,
      input ack,
      input [9:0] state, // 10-bit one-hot current state
      output B3_next,
      output S_next,
      output S1_next,
      output Count_next,
      output Wait_next,
      output done,
      output counting,
      output shift_ena
    );

    Requirements:
    - Implement the module logic using `assign` statements where possible.
    - Follow Verilog-2001 standards.
    - Output ONLY the Verilog module code.
    - Do NOT include the testbench.

  # Reduce context usage
  num_top_programs: 0
  num_diverse_programs: 0
  include_artifacts: false

# Database configuration
database:
  population_size: 10 
  archive_size: 5
  num_islands: 1
  programs_per_island: 10
  elite_selection_ratio: 0.2
  exploitation_ratio: 0.7
  
  # Embedding model (CPU offloaded)
  embedding_model: "embedding_models/Nomic-Embed-Code/nomic-embed-code-q5_k_m.gguf"
  similarity_threshold: 0.95

# Evaluator configuration
evaluator:
  timeout: 30
  parallel_evaluations: 2

# Evolution settings
diff_based_evolution: false 
max_code_length: 5000
